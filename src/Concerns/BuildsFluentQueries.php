<?php

declare(strict_types=1);

namespace Matchory\Elasticsearch\Concerns;

use ArrayObject;
use Illuminate\Support\Arr;
use JetBrains\PhpStorm\Deprecated;
use Matchory\Elasticsearch\Builder;

use function array_filter;
use function array_key_exists;
use function array_merge;
use function array_unique;
use function array_values;
use function count;
use function implode;
use function in_array;
use function is_array;
use function is_bool;
use function is_callable;
use function is_string;
use function tap;
use function value;

use const SORT_REGULAR;

/**
 * @template T of \Matchory\Elasticsearch\Model
 */
trait BuildsFluentQueries
{
    /**
     * Starting document offset
     *
     * Starting document offset. Defaults to `0`.
     *
     * By default, you cannot page through more than 10,000 hits using the
     * `from` and `size` parameters. To page through more hits, use the
     * `search_after` parameter.
     *
     * @var int
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-search.html#search-type
     */
    protected int $from = Builder::DEFAULT_OFFSET;

    /**
     * Unique document ID
     *
     * Each document has an `_id` that uniquely identifies it, which is indexed
     * so that documents can be looked up either with the GET API or the
     * `ids` query.
     * The `_id` can either be assigned at indexing time, or a unique `_id` can
     * be generated by Elasticsearch. This field is not configurable in
     * the mappings.
     *
     * The value of the `_id` field is accessible in queries such as `term`,
     * `terms`, `match`, and `query_string`.
     *
     * The `_id` field is restricted from use in aggregations, sorting, and
     * scripting. In case sorting or aggregating on the `_id` field is required,
     * it is advised to duplicate the content of the `_id` field into another
     * field that has `doc_values` enabled.
     *
     * @var string|null
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/mapping-id-field.html
     */
    protected string|null $id = null;

    /**
     * Index name
     *
     * Name of the index to query. To search all data streams and indices in a
     * cluster, omit this parameter or use _all or *.
     * An index can be thought of as an optimized collection of documents and
     * each document is a collection of fields, which are the key-value pairs
     * that contain your data. By default, Elasticsearch indexes all data in
     * every field and each indexed field has a dedicated, optimized data
     * structure. For example, text fields are stored in inverted indices, and
     * numeric and geo fields are stored in BKD trees. The ability to use the
     * per-field data structures to assemble and return search results is what
     * makes Elasticsearch so fast.
     *
     * @var string|null
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-search.html
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/documents-indices.html
     */
    protected string|null $index = null;

    /**
     * Filter operators
     *
     * @var string[]
     */
    protected array $operators = [
        Builder::OPERATOR_EQUAL,
        Builder::OPERATOR_NOT_EQUAL,
        Builder::OPERATOR_GREATER_THAN,
        Builder::OPERATOR_GREATER_THAN_OR_EQUAL,
        Builder::OPERATOR_LOWER_THAN,
        Builder::OPERATOR_LOWER_THAN_OR_EQUAL,
        Builder::OPERATOR_LIKE,
        Builder::OPERATOR_EXISTS,
    ];

    /**
     * Scroll
     *
     * While a search request returns a single “page” of results, the scroll API
     * can be used to retrieve large numbers of results (or even all results)
     * from a single search request, in much the same way as you would use a
     * cursor on a traditional database.
     *
     * Scrolling is not intended for real time user requests, but rather for
     * processing large amounts of data, e.g. in order to reindex the contents
     * of one index into a new index with a different configuration.
     *
     * The results that are returned from a scroll request reflect the state of
     * the index at the time that the initial search request was made, like a
     * snapshot in time. Subsequent changes to documents (index, update or
     * delete) will only affect later search requests.
     *
     * In order to use scrolling, the initial search request should specify the
     * scroll parameter in the query string, which tells Elasticsearch how long
     * it should keep the “search context” alive (see Keeping the search context
     * alive), eg ?scroll=1m.
     *
     * @var string|null
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/paginate-search-results.html#scroll-search-results
     */
    protected string|null $scroll = null;

    /**
     * Scroll ID
     *
     * Identifier for the search and its search context.
     * You can use this scroll ID with the scroll API to retrieve the next batch
     * of search results for the request. See Scroll search results.
     * This parameter is only returned if the scroll query parameter is
     * specified in the request.
     *
     * @var string|null
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/paginate-search-results.html#scroll-search-results
     */
    protected string|null $scrollId = null;

    /**
     * Search Type
     *
     * There are different execution paths that can be done when executing a
     * distributed search. The distributed search operation needs to be
     * scattered to all the relevant shards and then all the results are
     * gathered back. When doing scatter/gather type execution, there are
     * several ways to do that, specifically with search engines.
     *
     * One of the questions when executing a distributed search is how many
     * results to retrieve from each shard. For example, if we have 10 shards,
     * the 1st shard might hold the most relevant results from 0 till 10, with
     * other shards results ranking below it. For this reason, when executing a
     * request, we will need to get results from 0 till 10 from all shards, sort
     * them, and then return the results if we want to ensure correct results.
     *
     * Another question, which relates to the search engine, is the fact that
     * each shard stands on its own. When a query is executed on a specific
     * shard, it does not take into account term frequencies and other search
     * engine information from the other shards. If we want to support accurate
     * ranking, we would need to first gather the term frequencies from all
     * shards to calculate global term frequencies, then execute the query on
     * each shard using these global frequencies.
     *
     * Also, because of the need to sort the results, getting back a large
     * document set, or even scrolling it, while maintaining the correct sorting
     * behavior can be a very expensive operation. For large result set
     * scrolling, it is best to sort by _doc if the order in which documents are
     * returned is not important.
     *
     * Elasticsearch is very flexible and allows to control the type of search
     * to execute on a per search request basis. The type can be configured by
     * setting the search_type parameter in the query string. The types are:
     *
     * Query Then Fetch
     * ----------------
     * Parameter value: `query_then_fetch`.
     *
     * Distributed term frequencies are calculated locally for each shard
     * running the search. We recommend this option for faster searches with
     * potentially less accurate scoring.
     *
     * This is the default setting, if you do not specify a `search_type` in
     * your request.
     *
     * Dfs, Query Then Fetch
     * ---------------------
     * Parameter value: `dfs_query_then_fetch`.
     *
     * Distributed term frequencies are calculated globally, using information
     * gathered from all shards running the search. While this option increases
     * the accuracy of scoring, it adds a round-trip to each shard, which can
     * result in slower searches.
     *
     * @var string|null
     * @psalm-var 'query_then_fetch'|'dfs_query_then_fetch'
     * @see       https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-search.html#search-type
     */
    protected string|null $searchType = null;

    /**
     * Number of hits to return
     *
     * Defines the number of hits to return. Defaults to `10`.
     *
     * By default, you cannot page through more than 10,000 hits using the
     * `from` and `size` parameters. To page through more hits, use the
     * `search_after` parameter.
     *
     * @var int
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/7.10/search-search.html#search-type
     */
    protected int $size = Builder::DEFAULT_LIMIT;

    /**
     * Runtime field
     *
     * A runtime field is a field that is evaluated at query time. Runtime fields enable you to:
     * Add fields to existing documents without reindexing your data
     * Start working with your data without understanding how it’s structured
     * Override the value returned from an indexed field at query time
     * Define fields for a specific use without modifying the underlying schema
     *
     * You access runtime fields from the search API like any other field, and Elasticsearch sees runtime fields no
     * differently. You can define runtime fields in the index mapping or in the search request. Your choice, which
     * is part of the inherent flexibility of runtime fields.
     *
     * @var array
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/8.6/search-fields.html#script-fields
     */
    protected array $scriptFields = [];

    /**
     * Query sort fields
     *
     * @var array
     */
    protected array $sort = [];

    /**
     * Query returned fields list
     *
     * @var array|null
     */
    protected array|null $source = null;

    /**
     * Result aggregations
     *
     * @var array
     */
    private array $aggregations = [];

    /**
     * Query body
     *
     * @var array
     */
    private array $body = [];

    /**
     * Query bool filter
     *
     * @var array
     */
    private array $filter = [];

    /**
     * Ignored HTTP errors
     *
     * @var array
     */
    private array $ignores = [];

    /**
     * Query bool must
     *
     * @var array
     */
    private array $must = [];

    /**
     * Query bool must not
     *
     * @var array
     */
    private array $mustNot = [];

    private array $should = [];

    /**
     * Retrieves the ID the query is restricted to.
     *
     * @return string|null
     */
    public function getId(): string|null
    {
        return $this->id;
    }

    /**
     * Retrieves all ignored fields
     *
     * @return array
     */
    public function getIgnores(): array
    {
        return $this->ignores;
    }

    /**
     * Retrieves the name of the index used for the query.
     *
     * @return string|null
     */
    public function getIndex(): string|null
    {
        return $this->index;
    }

    /**
     * Get the query scroll
     *
     * @return string|null
     */
    public function getScroll(): string|null
    {
        return $this->scroll;
    }

    public function getScrollId(): string|null
    {
        return $this->scrollId;
    }

    /**
     * Retrieves the query search type.
     *
     * @return string|null
     * @psalm-return 'query_then_fetch'|'dfs_query_then_fetch'
     * @see          https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-request-search-type.html
     */
    public function getSearchType(): string|null
    {
        return $this->searchType;
    }

    /**
     * Sets a property on the query body.
     *
     * This method accepts a path to the property to set, for example
     * "query.bool.filter.2", and an arbitrary value to set the property to.
     *
     * @param string $path
     * @param mixed  $value
     *
     * @return $this
     */
    public function set(string $path, mixed $value): static
    {
        Arr::set($this->body, $path, $value);

        return $this;
    }

    /**
     * Add an aggregation to the query.
     *
     * An aggregation summarizes your data as metrics, statistics, or other
     * analytics. Aggregations help you answer questions like:
     *  - What’s the average load time for my website?
     *  - Who are my most valuable customers based on transaction volume?
     *  - What would be considered a large file on my network?
     *  - How many products are in each product category?
     *
     * Elasticsearch organizes aggregations into three categories:
     * Metric aggregations that calculate metrics, such as a sum or average,
     * from field values.
     * Bucket aggregations that group documents into buckets, also called bins,
     * based on field values, ranges, or other criteria.
     * Pipeline aggregations that take input from other aggregations instead of
     * documents or fields.
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html
     *
     * @param string            $name       Name of the aggregation.
     * @param array|string|null $parameters Aggregation configuration. If a
     *                                      string will be assumed the name of a
     *                                      field to aggregate. If an array,
     *                                      will be used as the aggregation
     *                                      configuration. If omitted, a simple
     *                                      terms aggregation will be used as a
     *                                      default value, using the aggregation
     *                                      name as the field.
     *
     * @return Builder<T>&static
     */
    public function aggregate(
        string $name,
        array|string $parameters = null
    ): static {
        $field = is_string($parameters) ? $parameters : $name;
        $parameters = is_array($parameters)
            ? $parameters
            : [
                'terms' => [
                    'field' => $field,
                ],
            ];

        $this->aggregations[$name] = $parameters;

        return $this;
    }

    /**
     * Retrieves all documents.
     *
     * The most simple query, which matches all documents, giving them all a
     * _score of 1.0. The _score can be changed with the boost parameter.
     *
     * @param float|null $boost
     *
     * @return $this
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-all-query
     */
    public function all(float|null $boost = null): static
    {
        return $this->body([
            'query' => [
                'match_all' => $boost !== null
                    ? ['boost' => $boost]
                    : new ArrayObject(),
            ],
        ]);
    }

    /**
     * Sets the query body.
     *
     * @param array $body
     *
     * @return Builder<T>&static
     */
    public function body(array $body = []): static
    {
        $this->body = $body;

        return $this;
    }

    /**
     * Sets runtime fields.
     *
     * @param array $runtimeFields
     *
     * @return Builder<T>&static
     */
    public function runtimeFields(array $runtimeFields = []): static
    {
        $this->runtimeFields = $runtimeFields;

        return $this;
    }

    /**
     * Get the runtime fields
     *
     * @return array|null
     */
    public function getRuntimeFields(): array|null
    {
        return $this->runtimeFields;
    }

    /**
     * Add a condition to find documents which are some distance away from the
     * given geo point.
     *
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/2.4/query-dsl-geo-distance-query.html
     *
     * @param callable|string $name     A name of the field.
     * @param string|array    $value    A starting geo point which can be
     *                                  represented by a string 'lat,lon', an
     *                                  object like `{'lat': lat, 'lon': lon}`
     *                                  or an array like `[lon,lat]`.
     * @param string          $distance A distance from the starting geo point.
     *                                  It can be for example '20km'.
     *
     * @return Builder<T>&static
     */
    public function distanceFilter(
        callable|string $name,
        string|array $value,
        string $distance
    ): static {
        if (is_callable($name)) {
            return tap($this, $name);
        }

        return $this->filter('geo_distance', [
            $name => $value,
            'distance' => $distance,
        ]);
    }

    /**
     * Define the source document fields to exclude from the response
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     */
    public function exclude(array|string ...$args): static
    {
        $fields = $this->flattenArgs($args);

        $this->source['excludes'] = array_values(
            array_unique(array_merge(
                $this->source['excludes'] ?? [],
                $fields
            ))
        );

        $this->source['includes'] = array_values(
            array_filter(
                $this->source['includes'] ?? [],
                fn($field) => ! in_array(
                    $field,
                    $this->source['excludes'] ?? [],
                    false
                )
            )
        );

        return $this;
    }

    /**
     * Adds a filter to the query.
     *
     * @param string $type
     * @param array  $parameters
     *
     * @return $this
     */
    public function filter(string $type, array $parameters): static
    {
        $this->filter[] = [
            $type => $parameters,
        ];

        return $this;
    }

    /**
     * Set the collapse field
     *
     * @param string $field
     *
     * @return Builder<T>&static
     */
    public function groupBy(string $field): static
    {
        return $this->set('collapse.field', $field);
    }

    /**
     * Get highlight result
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     */
    public function highlight(array|string ...$args): static
    {
        $fields = $this->flattenArgs($args);
        $highlights = [];

        foreach ($fields as $field) {
            $highlights[$field] = new ArrayObject();
        }

        return $this->set('highlight.fields', $highlights);
    }

    /**
     * Adds a term filter for the `_id` field.
     *
     * @param string|null $id
     *
     * @return Builder<T>&static
     */
    public function id(string|null $id = null): static
    {
        $this->id = $id;

        if ($id) {
            $this->filter[] = [
                'term' => [
                    '_id' => $id,
                ],
            ];
        }

        return $this;
    }

    /**
     * Avoids throwing an error on unsuccessful responses from the Elasticsearch
     * server, as returned by the Elasticsearch client.
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     */
    public function ignore(array|string ...$args): static
    {
        $this->ignores = array_merge(
            $this->ignores,
            $this->flattenArgs($args)
        );

        $this->ignores = array_unique($this->ignores);

        return $this;
    }

    /**
     * Define the source document fields to include in the response
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     */
    public function include(array|string ...$args): static
    {
        $fields = $this->flattenArgs($args);

        $this->source['includes'] = array_values(
            array_unique(array_merge(
                $this->source['includes'] ?? [],
                $fields
            ))
        );

        $this->source['excludes'] = array_values(
            array_filter(
                $this->source['excludes'] ?? [],
                fn($field) => ! in_array(
                    $field,
                    $this->source['includes'] ?? [],
                    true
                )
            )
        );

        return $this;
    }

    /**
     * Sets the name of the index to use for the query.
     *
     * @param string|null $index
     *
     * @return Builder<T>&static
     */
    public function index(string|null $index = null): static
    {
        $this->index = $index;

        return $this;
    }

    /**
     * Shorthand to add a "match" filter.
     *
     * @param string                $field Name of the field to add a filter for
     * @param callable|array|string $value Filter value. Either a string value,
     *                                     an array of Elasticsearch parameters,
     *                                     or a callable that returns either of
     *                                     the previous.
     *
     * @return Builder<T>&static
     */
    public function matchFilter(
        string $field,
        callable|array|string $value
    ): static {
        return $this->filter('match', [
            $field => value($value, $this, $field),
        ]);
    }

    public function minimumShouldMatch(int $amount): static
    {
        $this->set('query.bool.minimum_should_match', $amount);

        return $this;
    }

    /**
     * Adds a must condition to the query.
     *
     * @param string $type       Query type
     * @param array  $parameters Parameters to the query
     *
     * @return Builder<T>&static
     */
    public function must(string $type, array $parameters): static
    {
        $this->must[] = [
            $type => $parameters,
        ];

        return $this;
    }

    /**
     * Adds a must_not condition to the query.
     *
     * @param string $type       Query type
     * @param array  $parameters Parameters to the query
     *
     * @return Builder<T>&static
     */
    public function mustNot(string $type, array $parameters): static
    {
        $this->mustNot[] = [
            $type => $parameters,
        ];

        return $this;
    }

    /**
     * @param string        $path
     * @param array|Builder $query
     * @param string        $scoreMode
     *
     * @return Builder<T>&static
     */
    public function nested(
        string $path,
        array|Builder $query,
        string $scoreMode = 'avg'
    ): static {
        $this->set('query.nested', [
            'score_mode' => $scoreMode,
            'path' => $path,
            'query' => $query instanceof Builder
                ? Arr::get($query->toArray(), 'body.query')
                : $query,
        ]);

        return $this;
    }

    /**
     * Retrieves no documents.
     *
     * This is the inverse of the match_all query, which matches no documents.
     * Most useful in specialized queries only intended to retrieve aggregations
     * or suggestions.
     *
     * @return $this
     * @see BuildsFluentQueries::all()
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html#query-dsl-match-none-query
     */
    public function none(): static
    {
        return $this->body([
            'query' => [
                'match_none' => new ArrayObject(),
            ],
        ]);
    }

    /**
     * Set the sorting field
     *
     * @param int|string $field
     * @param string     $direction
     *
     * @return Builder<T>&static
     */
    public function orderBy(
        int|string $field,
        string $direction = 'asc'
    ): static {
        $this->sort[] = [
            $field => $direction,
        ];

        return $this;
    }

    /**
     * Promotes selected documents to rank higher than those matching a given
     * query. This feature is typically used to guide searchers to curated
     * documents that are promoted over and above any "organic" matches for a
     * search. The promoted or "pinned" documents are identified using the
     * document IDs stored in the _id field.
     *
     * @param array              $ids
     * @param array|Builder|null $query
     *
     * @return $this
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-pinned-query.html
     */
    public function pinned(array $ids, array|Builder|null $query = null): static
    {
        if ($query === null) {
            /** @noinspection CallableParameterUseCaseInTypeContextInspection */
            $query = (clone $this)->none();
        }

        $organic = $query instanceof Builder
            ? Arr::get($query->toArray(), 'body.query')
            : $query;

        return $this->body([
            'query' => [
                'pinned' => [
                    'ids' => $ids,
                    'organic' => $organic,
                ],
            ],
        ]);
    }

    /**
     * Shorthand to add a "prefix" filter.
     *
     * @param string                $field Name of the field to add a filter for
     * @param callable|array|string $value Filter value. Either a string value,
     *                                     an array of Elasticsearch parameters,
     *                                     or a callable that returns either of
     *                                     the previous.
     *
     * @return Builder<T>&static
     */
    public function prefixFilter(
        string $field,
        callable|array|string $value,
        bool $caseSensitive = true
    ): static {
        $parameters = [
            'value' => value($value, $this, $field),
        ];

        if ( ! $caseSensitive) {
            $parameters['case_insensitive'] = true;
        }

        return $this->filter('prefix', [
            $field => $parameters,
        ]);
    }

    /**
     * Shorthand to add a "range" filter.
     *
     * @param string                               $field    Name of the field
     *                                                       to add a filter for
     * @param callable|array|string                $operator Range comparison
     *                                                       operator as a
     *                                                       string, an array of
     *                                                       custom range
     *                                                       comparison
     *                                                       parameters or a
     *                                                       callable that
     *                                                       returns either of
     *                                                       the previous.
     * @param callable|array|string|null|int|float $value    Filter value.
     *                                                       Either a string
     *                                                       value, an array of
     *                                                       Elasticsearch
     *                                                       parameters, or a
     *                                                       callable that
     *                                                       returns either of
     *                                                       the previous. Only
     *                                                       used if a string
     *                                                       operator has been
     *                                                       passed as the
     *                                                       second argument.
     *
     * @return Builder<T>&static
     * @example $query->rangeFilter('year', ['gte' => 2006])
     * @example $query->rangeFilter('year', ['gte' => 2006, 'lt' => 2021])
     * @example $query->rangeFilter('year', fn($q, $field) => 'lt', 2021)
     * @example $query->rangeFilter('year', fn($q, $field) => ['lt' => 2021])
     *
     * @example $query->rangeFilter('year', 'gt', '2006')
     */
    public function rangeFilter(
        string $field,
        callable|array|string $operator,
        callable|array|string|int|float $value = null
    ): static {
        $operator = value($operator, $this, $field);

        if (is_string($operator) && $value) {
            return $this->filter('range', [
                $field => [
                    $operator => value($value, $this, $field),
                ],
            ]);
        }

        return $this->filter('range', [
            $field => $operator,
        ]);
    }

    /**
     * Shorthand to add a "regexp" filter.
     *
     * @param string                $field                 Name of the field to
     *                                                     add a filter for
     * @param callable|array|string $value                 Filter value. Either
     *                                                     a string value, an
     *                                                     array of
     *                                                     Elasticsearch
     *                                                     parameters, or a
     *                                                     callable that returns
     *                                                     either of the
     *                                                     previous.
     * @param int|null              $flags                 Enables optional
     *                                                     operators for the
     *                                                     regular expression.
     * @param bool|null             $caseSensitive         Allows case
     *                                                     insensitive matching
     *                                                     of the regular
     *                                                     expression
     *                                                     value with the
     *                                                     indexed field values
     *                                                     when set to true.
     *                                                     Default is false
     *                                                     which means the case
     *                                                     sensitivity of
     *                                                     matching depends on
     *                                                     the underlying
     *                                                     field’s mapping.
     * @param int|null              $maxDeterminizedStates Maximum number of
     *                                                     automaton states
     *                                                     required for the
     *                                                     query.
     *                                                     Default is 10000.
     *                                                     Elasticsearch uses
     *                                                     Apache Lucene
     *                                                     internally to parse
     *                                                     regular expressions.
     *                                                     Lucene converts each
     *                                                     regular expression to
     *                                                     a finite automaton
     *                                                     containing a number
     *                                                     of determinized
     *                                                     states. You can use
     *                                                     this parameter to
     *                                                     prevent that
     *                                                     conversion from
     *                                                     unintentionally
     *                                                     consuming too
     *                                                     many resources. You
     *                                                     may need to increase
     *                                                     this limit to run
     *                                                     complex regular
     *                                                     expressions.
     *
     * @return Builder<T>&static
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html
     * @see https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html#regexp-optional-operators
     */
    public function regexpFilter(
        string $field,
        callable|array|string $value,
        int|null $flags = null,
        bool|null $caseSensitive = null,
        int|null $maxDeterminizedStates = null
    ): static {
        $value = value($value, $this, $field);

        if (is_array($value) || (
                $flags === null &&
                $caseSensitive === null &&
                $maxDeterminizedStates === null
            )) {
            return $this->filter('regexp', [
                $field => $value,
            ]);
        }

        $parameters = [
            'value' => $value,
        ];

        if ($flags !== null) {
            $stringFlags = $this->resolveRegexpFlags($flags);

            if ($stringFlags) {
                $parameters['flags'] = $stringFlags;
            }
        }

        if ($caseSensitive !== null) {
            $parameters['case_insensitive'] = ! $caseSensitive;
        }

        if ($maxDeterminizedStates !== null) {
            $parameters['max_determinized_states'] = $maxDeterminizedStates;
        }

        return $this->filter('regexp', [
            $field => $parameters,
        ]);
    }

    /**
     * Enables the scroll API. The argument may be used to set the duration to
     * keep the scroll ID alive for. Defaults to 5 minutes.
     *
     * @param string $keepAlive
     *
     * @return Builder<T>&static
     */
    public function scroll(string $keepAlive = '5m'): static
    {
        $this->scroll = $keepAlive;

        return $this;
    }

    /**
     * Sets the query scroll ID.
     *
     * @param string|null $scroll
     *
     * @return Builder<T>&static
     */
    public function scrollId(string|null $scroll): static
    {
        $this->scrollId = $scroll;

        return $this;
    }

    /**
     * Sets the query search type.
     *
     * @param string $type
     *
     * @return Builder<T>&static
     *
     * @psalm-param 'query_then_fetch'|'dfs_query_then_fetch' $type
     * @see         https://www.elastic.co/guide/en/elasticsearch/reference/6.8/search-request-search-type.html
     */
    public function searchType(string $type): static
    {
        $this->searchType = $type;

        return $this;
    }

    /**
     * Define the source document fields to include in the response
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     * @deprecated Use include instead
     */
    #[Deprecated(replacement: '%class%->include(%parametersList%)')]
    public function select(array|string ...$args): Builder
    {
        return $this->include(...$args);
    }

    /**
     * Adds a should condition to the query.
     *
     * @param string $type       Query type
     * @param array  $parameters Parameters to the query
     *
     * @return Builder<T>&static
     */
    public function should(string $type, array $parameters): static
    {
        $this->should[] = [
            $type => $parameters,
        ];

        return $this;
    }

    /**
     * Set the query offset
     *
     * @param int $from
     *
     * @return Builder<T>&static
     */
    public function skip(int $from = 0): static
    {
        $this->from = $from;

        return $this;
    }

    /**
     * The suggest feature suggests similar looking terms based on a provided
     * text by using a suggester. The `suggest` request part is defined
     * alongside the query part in a _search request. If the query part is
     * left out, only suggestions are returned.
     *
     * @param string $name
     * @param array  $parameters
     *
     * @return $this
     */
    public function suggest(string $name, array $parameters): static
    {
        return $this->set('suggest', [
            $name => $parameters,
        ]);
    }

    /**
     * Sets the number of hits to return from the result.
     *
     * @param int $size
     *
     * @return Builder<T>&static
     */
    public function take(int $size = Builder::DEFAULT_LIMIT): static
    {
        $this->size = $size;

        return $this;
    }

    /**
     * Shorthand to add a "term" filter.
     *
     * @param string                $field Name of the field to add a filter for
     * @param callable|array|string $value Filter value. Either a string value,
     *                                     an array of Elasticsearch parameters,
     *                                     or a callable that returns either of
     *                                     the previous.
     * @param float|int|null        $boost Floating point number used to
     *                                     decrease or increase the relevance
     *                                     scores of a query. Defaults to 1.0.
     *                                     You can use the boost parameter to
     *                                     adjust relevance scores for searches
     *                                     containing two or more queries.
     *                                     Boost values are relative to the
     *                                     default value of 1.0. A boost value
     *                                     between 0 and 1.0 decreases the
     *                                     relevance score. A value greater than
     *                                     1.0 increases the relevance score.     *
     *
     * @return Builder<T>&static
     */
    public function termFilter(
        string $field,
        mixed $value,
        float|int|null $boost = null
    ): static {
        $parameters = [
            $field => value($value, $this, $field),
        ];

        if ($boost !== null) {
            $parameters['boost'] = (float)$boost;
        }

        return $this->filter('term', $parameters);
    }

    /**
     * Shorthand to add a "terms" filter.
     *
     * @param string                $field Name of the field to add a filter for
     * @param callable|array|string $value Filter value. Either a string value,
     *                                     an array of Elasticsearch parameters,
     *                                     or a callable that returns either of
     *                                     the previous.
     * @param float|int|null        $boost Floating point number used to
     *                                     decrease or increase the relevance
     *                                     scores of a query. Defaults to 1.0.
     *                                     You can use the boost parameter to
     *                                     adjust relevance scores for searches
     *                                     containing two or more queries.
     *                                     Boost values are relative to the
     *                                     default value of 1.0. A boost value
     *                                     between 0 and 1.0 decreases the
     *                                     relevance score. A value greater than
     *                                     1.0 increases the relevance score.
     *
     * @return Builder<T>&static
     */
    public function termsFilter(
        string $field,
        callable|array|string $value,
        float|int|null $boost = null
    ): static {
        $value = value($value, $this, $field);
        $parameters = [
            $field => (array)$value,
        ];

        if ($boost !== null) {
            $parameters['boost'] = (float)$boost;
        }

        return $this->filter('terms', $parameters);
    }

    /**
     * Define the source document fields to exclude from the response
     *
     * @param array|string ...$args
     *
     * @return Builder<T>&static
     * @deprecated Use exclude instead
     */
    #[Deprecated(replacement: '%class%->exclude(%parametersList%)')]
    public function unselect(array|string ...$args): static
    {
        return $this->exclude(...$args);
    }

    /**
     * Adds a filter to the query
     *
     * @param callable|string $name
     * @param int|string|null $operator
     * @param mixed|null      $value
     *
     * @return Builder<T>&static
     */
    public function where(
        callable|string $name,
        int|string|null $operator = Builder::OPERATOR_EQUAL,
        mixed $value = null
    ): static {
        if (is_callable($name)) {
            $name($this);

            return $this;
        }

        if ( ! $this->isOperator((string)$operator)) {
            if ($value === null) {
                $value = $operator;
            }

            $operator = Builder::OPERATOR_EQUAL;
        }

        return match ((string)$operator) {
            Builder::OPERATOR_EQUAL => $name === '_id'
                ? $this->id((string)$value)
                : $this->termFilter($name, $value),

            Builder::OPERATOR_GREATER_THAN => $this->rangeFilter(
                $name,
                'gt',
                $value
            ),

            Builder::OPERATOR_GREATER_THAN_OR_EQUAL => $this->rangeFilter(
                $name,
                'gte',
                $value
            ),

            Builder::OPERATOR_LOWER_THAN => $this->rangeFilter(
                $name,
                'lt',
                $value
            ),

            Builder::OPERATOR_LOWER_THAN_OR_EQUAL => $this->rangeFilter(
                $name,
                'lte',
                $value
            ),

            Builder::OPERATOR_LIKE => $this->must('match', [
                $name => $value,
            ]),

            Builder::OPERATOR_EXISTS => $this->whereExists(
                $name,
                is_bool($value) ? $value : true
            ),

            // Should not be possible
            default => $this
        };
    }

    /**
     * Set the query where between clause
     *
     * @param string     $name
     * @param mixed      $firstValue
     * @param mixed|null $lastValue
     *
     * @return Builder<T>&static
     */
    public function whereBetween(
        string $name,
        mixed $firstValue,
        mixed $lastValue = null
    ): static {
        if (is_array($firstValue) && count($firstValue) === 2) {
            [$firstValue, $lastValue] = $firstValue;
        }

        return $this->filter('range', [
            $name => [
                'gte' => $firstValue,
                'lte' => $lastValue,
            ],
        ]);
    }

    /**
     * Set the query where exists clause
     *
     * @param string $name
     * @param bool   $exists
     *
     * @return Builder<T>&static
     */
    public function whereExists(string $name, bool $exists = true): static
    {
        if ($exists) {
            return $this->must('exists', [
                'field' => $name,
            ]);
        }

        return $this->mustNot('exists', [
            'field' => $name,
        ]);
    }

    /**
     * Set the query where in clause
     *
     * @param callable|string $name
     * @param callable|array  $value
     *
     * @return Builder<T>&static
     */
    public function whereIn(
        callable|string $name,
        callable|array $value = []
    ): static {
        if (is_callable($name)) {
            return tap($this, $name);
        }

        return $this->termsFilter($name, $value);
    }

    /**
     * Set the query inverse where clause
     *
     * @param callable|string $name
     * @param string          $operator
     * @param null            $value
     *
     * @return Builder<T>&static
     */
    public function whereNot(
        callable|string $name,
        string $operator = Builder::OPERATOR_EQUAL,
        $value = null
    ): static {
        if (is_callable($name)) {
            return tap($this, $name);
        }

        if ( ! $this->isOperator($operator)) {
            if ($value === null) {
                $value = $operator;
            }

            $operator = Builder::OPERATOR_EQUAL;
        }

        return match ($operator) {
            Builder::OPERATOR_EQUAL => $this->mustNot(
                'term',
                [$name => $value]
            ),

            Builder::OPERATOR_GREATER_THAN => $this->mustNot(
                'range',
                [
                    $name => ['gt' => $value],
                ]
            ),

            Builder::OPERATOR_GREATER_THAN_OR_EQUAL => $this->mustNot(
                'range',
                [
                    $name => ['gte' => $value],
                ]
            ),

            Builder::OPERATOR_LOWER_THAN => $this->mustNot(
                'range',
                [
                    $name => ['lt' => $value],
                ]
            ),

            Builder::OPERATOR_LOWER_THAN_OR_EQUAL => $this->mustNot(
                'range',
                [
                    $name => ['lte' => $value],
                ]
            ),

            Builder::OPERATOR_LIKE => $this->mustNot('match', [
                $name => $value,
            ]),

            Builder::OPERATOR_EXISTS => $this->whereExists(
                $name,
                is_bool($value) && ! $value
            ),

            // Should not be possible
            default => $this
        };
    }

    /**
     * Set the query where not between clause
     *
     * @param string     $name
     * @param mixed      $firstValue
     * @param mixed|null $lastValue
     *
     * @return Builder<T>&static
     */
    public function whereNotBetween(
        string $name,
        mixed $firstValue,
        mixed $lastValue = null
    ): static {
        if (is_array($firstValue) && count($firstValue) === 2) {
            [$firstValue, $lastValue] = $firstValue;
        }

        return $this->mustNot('range', [
            $name => [
                'gte' => $firstValue,
                'lte' => $lastValue,
            ],
        ]);
    }

    /**
     * Set the query where not in clause
     *
     * @param callable|string $name
     * @param mixed|array     $value
     *
     * @return Builder<T>&static
     */
    public function whereNotIn(callable|string $name, mixed $value = []): static
    {
        if (is_callable($name)) {
            return tap($this, $name);
        }

        return $this->mustNot('terms', [
            $name => $value,
        ]);
    }

    /**
     * Shorthand to add a "wildcard" filter.
     *
     * @param string                $field Name of the field to add a filter for
     * @param callable|array|string $value Filter value. Either a string value,
     *                                     an array of Elasticsearch parameters,
     *                                     or a callable that returns either of
     *                                     the previous.
     * @param float|int|null        $boost Floating point number used to
     *                                     decrease or increase the relevance
     *                                     scores of a query. Defaults to 1.0.
     *                                     You can use the boost parameter to
     *                                     adjust relevance scores for searches
     *                                     containing two or more queries.
     *                                     Boost values are relative to the
     *                                     default value of 1.0. A boost value
     *                                     between 0 and 1.0 decreases the
     *                                     relevance score. A value greater than
     *                                     1.0 increases the relevance score.     *
     *
     * @return Builder<T>&static
     */
    public function wildcardFilter(
        string $field,
        callable|array|string $value,
        float|int|null $boost = null
    ): static {
        $parameters = [
            'value' => value($value, $this, $field),
        ];

        if ($boost !== null) {
            $parameters['boost'] = (float)$boost;
        }

        return $this->filter('wildcard', [
            $field => $parameters,
        ]);
    }

    /**
     * Generate the query body
     *
     * @return array
     */
    protected function buildBody(): array
    {
        $body = $this->body;

        if ($this->source !== null) {
            $source = $body['_source'] ?? [];

            // TODO: Shouldn't the body-defined source take precedence here?
            $body['_source'] = array_merge(
                $source,
                $this->source
            );
        }

        $body['query'] = $body['query'] ?? [];

        if (count($this->must)) {
            Arr::set($body, 'query.bool.must', [
                ...Arr::get($body, 'query.bool.must', []),
                ...$this->must,
            ]);
        }

        if (count($this->mustNot)) {
            Arr::set($body, 'query.bool.must_not', [
                ...Arr::get($body, 'query.bool.must_not', []),
                ...$this->mustNot,
            ]);
        }

        if (count($this->should)) {
            Arr::set($body, 'query.bool.should', [
                ...Arr::get($body, 'query.bool.should', []),
                ...$this->should,
            ]);
        } else {
            unset($body['query']['bool']['minimum_should_match']);
        }

        if (count($this->filter)) {
            Arr::set($body, 'query.bool.filter', [
                ...Arr::get($body, 'query.bool.filter', []),
                ...$this->filter,
            ]);
        }

        if (count($body['query']) === 0) {
            unset($body['query']);
        }

        if (count($this->sort)) {
            $sortFields = array_key_exists('sort', $body)
                ? $body['sort']
                : [];

            $body['sort'] = array_unique(
                array_merge($sortFields, $this->sort),
                SORT_REGULAR
            );
        }

        if (count($this->aggregations)) {
            $aggregations = array_key_exists('aggs', $body)
                ? $body['aggs']
                : [];

            $body['aggs'] = array_merge(
                $aggregations,
                $this->aggregations
            );
        }

        $this->body = $body;

        return $body;
    }

    /**
     * Retrieves the number of hits to limit the query to.
     *
     * @return int
     */
    protected function getSize(): int
    {
        return $this->size;
    }

    /**
     * Get the query offset
     *
     * @return int
     */
    protected function getSkip(): int
    {
        return $this->from;
    }

    /**
     * check if it's a valid operator
     *
     * @param string $string
     *
     * @return bool
     */
    protected function isOperator(string $string): bool
    {
        return in_array(
            $string,
            $this->operators,
            true
        );
    }

    private function flattenArgs(array $args): array
    {
        $flattened = [];

        foreach ($args as $arg) {
            if (is_array($arg)) {
                /** @noinspection SlowArrayOperationsInLoopInspection */
                $flattened = array_merge($flattened, $arg);
            } else {
                $flattened[] = $arg;
            }
        }

        return $flattened;
    }

    private function resolveRegexpFlags(int $flags): string|null
    {
        $stringFlags = [];

        if ($flags & Builder::REGEXP_FLAG_NONE) {
            $stringFlags[] = 'NONE';

            return implode('|', $stringFlags);
        }

        if ($flags & Builder::REGEXP_FLAG_ALL) {
            $stringFlags[] = 'ALL';
        }

        if ($flags & Builder::REGEXP_FLAG_COMPLEMENT) {
            $stringFlags[] = 'COMPLEMENT';
        }

        if ($flags & Builder::REGEXP_FLAG_INTERVAL) {
            $stringFlags[] = 'INTERVAL';
        }

        if ($flags & Builder::REGEXP_FLAG_INTERSECTION) {
            $stringFlags[] = 'INTERSECTION';
        }

        if ($flags & Builder::REGEXP_FLAG_ANYSTRING) {
            $stringFlags[] = 'ANYSTRING';
        }

        if (empty($stringFlags)) {
            return null;
        }

        return implode('|', $stringFlags);
    }
}
